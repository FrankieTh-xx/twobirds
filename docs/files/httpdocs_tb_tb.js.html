<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>httpdocs/tb/tb.js - twoBirds API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="twoBirds API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 6.0a</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/tb.html">tb</a></li>
                                <li><a href="../classes/tb.Model.html">tb.Model</a></li>
                                <li><a href="../classes/TbEvent.html">TbEvent</a></li>
                                <li><a href="../classes/TbSelector.html">TbSelector</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: httpdocs/tb/tb.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * twoBirds V6 core functionality
 *
 * @author          frank.thuerigen &lt;frank_thuerigen@yahoo.de&gt;
 * @copyright       copyright (c) 2006- by author, unlimited license granted
 * @license         http://www.gnu.org/copyleft/gpl.html GNU GPL v3
 *
 */

tb = (function(){
    //private

    /**
     * walk all pSelector tb objects, call pMethodName on them
     * return a UNIQUE TbSelector result set containing all single results
     *
     * @function walkSelector
     * @private
     *
     * @param {object} pSelectorObject - instanceOf TbSelector
     * @param {string} pMethodName - name of method to call
     * @param {*} [pArguments] - arguments
     *
     * @return {object} instance of TbSelector
     */
    function walkSelector( pSelectorObject, pMethodName, pArguments ){
        var that = this,
            result,
            ret = tb( &#x27;&#x27; ); // empty tb selector object

        if ( pSelectorObject instanceof TbSelector ) {
            $.each(
                $.makeArray( pSelectorObject ),     // convert these results to true array
                function walkSelectorEach( key, tbObject ) {
                    result = tbObject[pMethodName].apply( tbObject, $.makeArray( pArguments ) );
                    $.each(
                        $.makeArray( result ),
                        function( key, resultObject ){
                            if ( Array.prototype.indexOf.call( ret, resultObject ) === -1 ){
                                Array.prototype.push.call( ret, resultObject );
                            }
                        }
                    );
                }
            );
        }
        return ret;
    }

    /**
     * standard twobirds event, internal use only
     *
     * @class TbEvent
     * @constructor
     * @private
     * @ignore
     *
     * @param {string} pEventName - name of event
     * @param {*} [pEventData] - data to be appended to this event
     * @param {string} [pBubble=l] - bubbling indicator, &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down or any combination
     *
     * @return {object} TbEvent instance
     */
    function TbEvent( pEventName, pEventData, pBubble ){
        $.extend(
            true,
            this,
            {   // default config
                bubble: pBubble || &#x27;l&#x27;,
                data: pEventData || {},
                name: pEventName || &#x27;&#x27;,
                __stopped__: false,
                __immediateStopped__: false
            }
        );
    };

    TbEvent.prototype = {

        /**
         * stop propagation after all handlers on this object have run
         *
         * @method stopPropagation
         *
         * @return {object} TbEvent object
         */
        stopPropagation: function(){
            this.__stopped__ = true;
            return this;
        },

        /**
         * stop propagation immediately after this handler has run
         *
         * @method stopImmediatePropagation
         *
         * @return {object} TbEvent object
         */
        stopImmediatePropagation: function(){
            this.stopPropagation(); // also stop normal propagation
            this.__immediateStopped__ = true;
            return this;
        }

    };

    /**
     * TbSelector constructor, internal use only
     *
     * creates an array-like object containing the tb objects defined by pSelector parameter
     *
     * sample calls:
     * new TbSelector( &#x27;&#x27; )
     * - create an empty result set
     * new TbSelector( &#x27;div.myClass&#x27; )
     * - returns all tb objects that were in the selected DOM elements.
     * - uses jQuery to find DOM elements, so parameter equals jQuery selector string.
     * new TbSelector( /ns1.ns2.myClassName/ )
     * - returns all tb elements (e.g. namespace ns1.ns2.myClassName) in current DOM,
     * - matches namespace property with regex.
     * new TbSelector( &#x27;*&#x27; )
     * new TbSelector( /./ )
     * - all tb elements in DOM
     * new TbSelector( document.body )
     * - selection by DOM node
     * new TbSelector( ns1.ns2.&lt;className&gt; )
     * - all tb elements in current DOM that are instances of the given class
     *
     * @class TbSelector
     * @constructor
     * @chainable
     * @private
     *
     * @param {string | regEx | constructor} pSelector - multiple selector types
     *
     * @return {object} TbSelector instance, array-like object
     */
    function TbSelector( pSelector ){

        var that = this,
            elements,
            isTbObject;

        that.length = 0;

        switch (typeof pSelector) {

            // selection by jQuery selector string
            case &#x27;string&#x27;:

                elements = $(pSelector).filter(function () {
                    return ($(this).data(&#x27;tbo&#x27;) !== undefined);
                });

                $.each(
                    elements,
                    function ( key, value ) {
                        var obj = $( value ).data( &#x27;tbo&#x27; );
                        Array.prototype.push.call( that, obj );
                    }
                );

                break;

            // selection by regEx: get all tb instances from DOM
            // check whether they contain a &quot;namespace&quot; property that matches regexp
            // selection by HTML node: get tb instances contained in node
            case &#x27;object&#x27;:

                if ( pSelector instanceof RegExp ){ // it is a regular expression

                    elements = $(&#x27;[data-tb]&#x27;).filter( function () {
                        var obj = $(this).data( &#x27;tbo&#x27; );

                        isTbObject = typeof obj === &#x27;object&#x27; &amp;&amp; obj.__tb__;

                        return isTbObject;
                    });

                    $.each(
                        elements,
                        function ( key, value ) {
                            var obj = $( value ).data( &#x27;tbo&#x27; );

                            if ( typeof obj.namespace === &#x27;string&#x27; &amp;&amp; obj.namespace.match( pSelector ) ){
                                Array.prototype.push.call( that, obj );
                            }
                        }
                    );

                } else if ( typeof pSelector.nodeType !== &#x27;undefined&#x27; ){
                    var obj = $(this).data( &#x27;tbo&#x27; );

                    isTbObject = typeof obj === &#x27;object&#x27; &amp;&amp; obj.__tb__;

                    if( isTbObject ){
                        Array.prototype.push.call( that, obj );
                    }
                }

                break;

            // selection by constructor: get all tb instances from DOM,
            // check whether their prototype matches constructor prototype
            case &#x27;function&#x27;:

                elements = $(&#x27;[data-tb]&#x27;).filter( function () {
                    var obj = $(this).data( &#x27;tbo&#x27; );

                    isTbObject = typeof obj === &#x27;object&#x27; &amp;&amp; obj.__tb__;

                    return isTbObject;
                });


                $.each(
                    elements,
                    function ( key, value ) {
                        var obj = $( value ).data( &#x27;tbo&#x27;),
                            objNamespace = pSelector.prototype.namespace || &#x27;&#x27;,
                            data_tb = $( value ).attr(&#x27;data-tb&#x27;);

                        if ( objNamespace === data_tb ){
                            Array.prototype.push.call( that, obj );
                        }
                    }
                );
                break;
        }
    };

    TbSelector.prototype = (function(){
        // private static

        return {
            // public methods and properties

            /**
             * trigger an event, optionally with data and bubble indicator
             *
             * @method trigger
             *
             * @param {string|object} pEvent - name of event or TbEvent instance or TbEvent instance
             * @param {*} [pEventData] - event data, usally an object
             * @param {string} [pBubble=l] - bubbling indicator : &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down or any combination
             *
             * @return {object} - (this) -&gt; TbSelector instance or tb object
             */
            trigger: function( pEvent, pEventData, pBubble ){
                var that = this,
                    TbEvent,
                    newHandlers;

                if( tb.stop() ){ // @todo rethink this, may be misleading since it seems to stop tb event handling but doesnt
                    console.info( &#x27;stopped TbEvent&#x27;, arguments );
                    return;
                }

                // construct event if necessary
                TbEvent = pEvent instanceof TbEvent ? pEvent : new TbEvent( pEvent, pEventData, pBubble );

                // execute handlers via setTimeout
                if ( that instanceof TbSelector ) {
                    $.each(
                        $.makeArray( that ),
                        function( key, tbObject ) {
                            if ( tbObject ) tbObject.trigger( TbEvent );
                        }
                    );
                } else { // it must be a native tb object

                    if ( that.handlers[TbEvent.name] &amp;&amp; TbEvent.bubble.indexOf( &#x27;l&#x27; ) &gt; -1 ) {
                        newHandlers = [];

                        $.each(
                            that.handlers[TbEvent.name],
                            function (key, handler) {
                                setTimeout(
                                    function() {
                                        // call handler function
                                        // in the scope of the tbObject
                                        if ( TbEvent.bubble.indexOf(&#x27;l&#x27;) &gt; -1
                                            &amp;&amp; !TbEvent.__immediateStopped__ ){

                                            handler.apply(that, [TbEvent]);

                                        }
                                    },
                                    0
                                );

                                if ( !handler.once ) {
                                    newHandlers.push( that.handlers[TbEvent.name][ key ] );
                                }

                            }
                        );

                        that.handlers[TbEvent.name] = newHandlers;

                    }

                    //bubble
                    setTimeout(

                        function() {

                            // this will be called after all local event handlers have been called
                            // if one of these sets __stopped__ to true, bubbling is cancelled
                            if ( TbEvent.__stopped__ || TbEvent.__immediateStopped__  ) {
                                return;
                            }

                            // bubble up
                            if ( TbEvent.bubble.indexOf(&#x27;u&#x27;) &gt; -1 ){
                                TbEvent.bubble += TbEvent.bubble.indexOf(&#x27;l&#x27;) === -1 ? &#x27;l&#x27; : &#x27;&#x27;;
                                that.parent().trigger( TbEvent );
                            }

                            // bubble down
                            if ( TbEvent.bubble.indexOf(&#x27;d&#x27;) &gt; -1 ){
                                TbEvent.bubble += TbEvent.bubble.indexOf(&#x27;l&#x27;) === -1 ? &#x27;l&#x27; : &#x27;&#x27;;
                                that.children().trigger( TbEvent );
                            }

                        },

                        0
                    );

                }

                return that;

            },

            /**
             * parents() method
             * for each this[0...n] or this as tb() instance,
             * - get all parent tb objects
             * - check them against the filter param pSelector
             * - return them as a TbSelector result set (unique)
             *
             * @method parents
             *
             * @param {*} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            parents: function( pSelector ){
                var that = this,
                    ret = tb(&#x27;&#x27;),
                    done = false,
                    thisInstance;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parents&#x27;, arguments );

                } else if ( that.__tb__ &amp;&amp; !!that.target.nodeType ) { // it must be a native toplevel tb object

                    $( that.target )
                        .parents( &#x27;[data-tb]&#x27; )
                        .each( function(){
                            Array.prototype.push.call( ret, $(this).data(&#x27;tbo&#x27;) ); // push dom object to tb selector content
                        });

                } else { // it is an embedded object, local target is another (parent) tb object

                    thisInstance = that.target;

                    while ( !done ){
                        if( !!thisInstance.target.nodeType ){
                            done = true;
                        }
                        Array.prototype.push.call( ret, thisInstance ); // push dom object to tb selector content
                        thisInstance = thisInstance.target;
                    }

                }

                return pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             * parent() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get closest parent tb object
             *
             * - check all of them against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method parent
             *
             * @param {*} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            parent: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ),
                    result;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parent&#x27;, arguments );

                } else if ( that.__tb__ &amp;&amp; !!that.target.nodeType ) { // it must be a native tb object

                    result = $( that.target )
                        .parents( &#x27;[data-tb]&#x27; )[0];

                    Array.prototype.push.call( ret, $( result ).data(&#x27;tbo&#x27;) );

                } else { // it is an embedded object, local target is another (parent) tb object

                    Array.prototype.push.call( ret, that.target ); // push dom object to tb selector content

                }
                return pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             * descendants() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get all descendants of tb object
             * - check them against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method descendants
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             * @param {boolean} [pLocalOnly] - only local descendants of given tb instance
             *
             * @return {object} - TbSelector instance
             */
            descendants: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb(&#x27;&#x27;);

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;descendants&#x27;, arguments );

                } else if ( that.__tb__ &amp;&amp; !!that.target.nodeType &amp;&amp; !pLocalOnly ) { // it must be a native tb object

                    $(that.target)
                        .find(&#x27;[data-tb]&#x27;)
                        .each(
                            function () {
                                Array.prototype.push.call( ret, $(this).data(&#x27;tbo&#x27;) );
                            }
                        );

                } else if ( !!pLocalOnly ){ // walk descendants

                    function walk( pObject ){

                        var children = pObject.children( false, true ); // false = no selector, true = only internal children

                        Array.prototype.push.call( ret, pObject ); // push object to tb selector content

                        if ( children.length ){
                            $.each(
                                $.makeArray( children ),
                                function( key, value ){
                                    walk( value );
                                }
                            );
                        }
                    }

                    // add local descendants
                    $.each(

                        $.makeArray( that.children( false, true ) ),

                        function( key, value ){
                            walk( value );
                        }

                    );

                }

                return !!pSelector ? ret.filter( selector ) : ret;

            },

            /**
             * children() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get all direct children of tb object
             * - check them against the filter param pSelector
             * - return TbSelector result set (unique)

             * @method children
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             * @param {boolean} [pLocalOnly] - only local children of given tb instance
             *
             * @return {object} - TbSelector instance
             */
            children: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb( &#x27;&#x27;); // empty tb selector object

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;children&#x27;, arguments );

                } else if ( that.__tb__ &amp;&amp; !!that.target.nodeType &amp;&amp; !pLocalOnly ) { // it must be a native tb object

                    $( that.target )
                        .find( &#x27;[data-tb]&#x27;)
                        .filter(
                            function() {
                                return $( this ).parents(&#x27;[data-tb]&#x27;)[0] === that.target;
                            }
                        )
                        .each(
                            function() {
                                Array.prototype.push.call( ret, $( this ).data(&#x27;tbo&#x27;) );
                            }
                        );

                } else if ( !!pLocalOnly ){

                    $.each(
                        that,
                        function( key, value ){
                            if ( typeof key === &#x27;string&#x27; &amp;&amp; key.indexOf( &#x27;.&#x27; )  &gt; -1 ){ // prop name contains &quot;.&quot;
                                Array.prototype.push.call( ret, value );
                            }
                        }
                    );

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             * next() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get the direct following sibling of tb object
             * - check it against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method next
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            next: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;next&#x27;, arguments );

                } else { // it must be a native tb object

                    result = that.parent().children();
                    index = Array.prototype.indexOf.call( result, that );

                    if ( result.length &gt; index + 1 ) {
                        Array.prototype.push.call( ret, result[ index + 1 ] ); // push dom object to tb selector content
                    }

                }
                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             * prev() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get the previous sibling of tb object
             * - check them against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method prev
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            prev: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;prev&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    index = Array.prototype.indexOf.call( result, this );

                    if ( index ) {
                        Array.prototype.push.call( ret, result[ index - 1 ] ); // push dom object to tb selector content
                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             * first() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get the first child of the tb object parent
             * - check it against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method first
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            first: function( pSelector ){
                var that = this,
                    ret = tb( &#x27;&#x27;),
                    result;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;first&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    Array.prototype.push.call( ret, result[ 0 ] ); // push dom object to tb selector content

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             * last() method
             *
             * for each this[0...n] or this as tb() instance,
             * - get the last child of the tb object parent
             * - check it against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method last
             *
             * @param {variant} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            last: function( pSelector ){
                var that = this,
                    ret = tb(&#x27;&#x27;),
                    result;

                if ( that instanceof TbSelector ) {
                    ret = walkSelector( this, &#x27;last&#x27;, arguments );
                } else {
                    result = this.parent().children();
                    Array.prototype.push.call( ret, result[ result.length - 1 ] ); // push dom object to tb selector content
                }
                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             * filter() method
             *
             * for each this[0...n] or this as tb() instance,
             * - check them against the filter param pSelector
             * - return TbSelector result set (unique)
             *
             * @method filter
             *
             * @param {*} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            filter: function( pSelector ){

                var that = this,
                    check = $.makeArray( tb( pSelector ) ), // object array to check against
                    ret = tb( &#x27;&#x27; );

                if ( !pSelector ) {
                    return that;
                }

                if ( that instanceof TbSelector ) {
                    $.each(
                        $.makeArray( that ),     // convert these results to true array
                        function( key, tbObject ) {
                            if ( check.indexOf( tbObject ) &gt; -1 ){
                                Array.prototype.push.call( ret, tbObject );
                            }
                        }
                    );
                } else {
                    if ( check.indexOf( that ) &gt; -1 ){
                        Array.prototype.push.call( ret, that );
                    }
                }

                return ret;
            },

            /**
             * not() method
             *
             * for each this[0...n] or this as tb() instance,
             * - check them against pSelector and remove all fits
             * - return TbSelector result set (unique)
             *
             * @method not
             *
             * @param {*} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            not: function( pSelector ){

                var that = this,
                    check = $.makeArray( tb( pSelector ) ), // object array to check against
                    ret,
                    index;

                if ( that instanceof TbSelector ) {
                    ret = that;
                } else {
                    ret = tb( &#x27;&#x27; );
                    Array.prototype.push.call( ret, that );
                }

                $.each(
                    check,
                    function( key, tbObject ) {

                        index = Array.prototype.indexOf.call( ret, tbObject );
                        if (  index &gt; -1 ){
                            Array.prototype.splice.apply( ret, [ index, 1 ] );
                        }

                    }
                );

                return ret;
            },

            /**
             * add() method
             *
             * add elements to current result set
             * - return TbSelector result set (unique)
             *
             * @method add
             *
             * @param {*} [pSelector] - any kind of TbSelector parameter
             *
             * @return {object} - TbSelector instance
             */
            add: function( pSelector ){

                var that = this,
                    check = $.makeArray( tb( pSelector ) ), // object array to check against
                    ret,
                    index;


                if ( that instanceof TbSelector ) {
                    ret = that;
                } else {
                    ret = tb( &#x27;&#x27; );
                    Array.prototype.push.call( ret, that );
                }

                $.each(
                    check,
                    function( key, tbObject ) {

                        index = Array.prototype.indexOf.call( ret, tbObject );

                        if (  index === -1 ){
                            Array.prototype.push.call( ret, tbObject );
                        }

                    }
                );

                return ret;
            },

            /**
             * on() method
             *
             * for each this[0...n] or this as tb() instance,
             * - add handler to handler array
             * - return TbSelector result set (unique)
             *
             * @method
             *
             * @param {string} pEventName - name of the handler function
             * @param {function} pHandler - the function to be added to the handler array
             * @param {boolean} [pOnce=false] - true = remove handler after first call, false = keep handler
             *
             * @return {object} - TbSelector instance
             */
            on: function( pEventName, pHandler, pOnce ){

                var that = this;

                pHandler.once = !!pHandler.once || !!pOnce;

                if ( that instanceof TbSelector ) {

                    walkSelector( that, &#x27;addHandler&#x27;, arguments );

                } else if ( that.__tb__ ) {

                    if ( !this.handlers[ pEventName ] ){
                        that.handlers[ pEventName ] = [];
                    }

                    that.handlers[ pEventName ].push( pHandler );
                }

                return that;

            },

            /**
             * one() method
             *
             * for each this[0...n] or this as tb() instance,
             * - add handler to handler array
             * - return TbSelector result set (unique)
             *
             * @method
             *
             * @param {string} pEventName - name of the handler function
             * @param {function} pHandler - the function to be added to the handler array
             *
             * @return {object} - TbSelector instance
             */
            one: function( pEventName, pHandler ){

                var that = this;

                that.on( pEventName, pHandler, true ); // add event that is only being triggered once

                return that;

            },

            /**
             * off() method
             *
             * for each this[0...n] or this as tb() instance,
             * - delete handler from handler array
             * - return TbSelector result set (unique)
             *
             * @method
             *
             * @param {string} pEventName - name of the handler function
             * @param {function} pHandler - the function to be added to the handler array
             *
             * @return {object} - TbSelector instance
             */
            off: function( pEventName, pHandler ){

                var that = this,
                    index;

                if ( that instanceof TbSelector ) {

                    walkSelector( that, &#x27;deleteHandler&#x27;, arguments );

                } else if ( that.__tb__ ) { // either a toplevel or an internal tb object

                    if ( !that.handlers[ pEventName ] ){
                        return;
                    }

                    index = that.handlers[ pEventName].indexOf( pHandler );

                    if ( index &gt; -1 ){
                        that.handlers[ pEventName ].splice( index, 1 );
                    }

                }

                return that;

            }

        };

    })();

    /**
     * tb() / new tb()
     * can be used as SELECTOR and CONSTRUCTOR
     *
     * sample call CONSTRUCTOR:
     * var a = new tb( &#x27;tb_repo_object_namespace&#x27; )
     *
     * sample call SELECTOR:
     * var result = tb( &#x27;div#app&#x27; )
     *
     * for selector functionality see TbSelector object
     *
     * @class tb
     * @constructor
     * @extends TbSelector
     *
     * @param {string}     arguments[0]   - namespace of class | TbSelector parameter
     * @param {*}  [ arguments[1] ] - config data ( if called as constructor )
     * @param {*}  [ arguments[2] ] - DOM target or parent tb instance
     *
     * @return {object} - twoBirds Object or TbSelector instance /w results
     *
     */
    function tb() {
        var that = this;

        /*
         arguments[0]: string, regEx or constructor function
         arguments[1]: optional object, parameter hash object if arguments[0] is constructor function
         arguments[2]: optional DOM node or parent tb object
         */

        function makePrototype( pConfig ){

            var f = function ( pConfig ){
                $.extend(
                    true,
                    this,
                    pConfig
                );
            };

            f.prototype = $.extend(
                true,
                {
                    constructor: tb
                },
                TbSelector.prototype
            );

            var r = new f( pConfig );

            return r;
        }


        if ( that instanceof tb ) {    // called as constructor, create and return tb object instance
            var isNamespace = typeof arguments[0] === &#x27;string&#x27;,
                tbClass =  isNamespace ? tb.namespace( arguments[0] ) : arguments[0],
                tbInstance,
                fileName;

            if ( isNamespace &amp;&amp; !tbClass ){
                fileName = arguments[0].replace( /\./g, &#x27;/&#x27; ) + &#x27;.js&#x27;;

                tb.head.load(
                    fileName,
                    (function( args ){
                        return function(){
                            //console.log( &#x27;args&#x27;, args );
                            new tb(
                                args[0],
                                args[1] || {},
                                args[2] || false
                            );
                        }
                    })( Array.prototype.slice.call( arguments ) )
                );

                return;
            }


            if ( typeof tbClass === &#x27;function&#x27; ){

                //console.log( &#x27;constructor&#x27;, arguments, tbClass);

                if ( !tbClass.prototype.__tb__ ){
                    // extend prototype with selector prototype
                    //console.log( &#x27;extend&#x27;, tbClass.name, tbClass.prototype );
                    tbClass.prototype = makePrototype( tbClass.prototype );
                    tbClass.prototype.__tb__ = &#x27;V6.0a&#x27;;
                }

                // make a new instance of given constructor
                tbInstance = new tbClass( arguments[1] || {}, arguments[2] ); // hidden parameter target
                //console.log( &#x27;tbInstance&#x27;, tbInstance );

                // prepare .namespace property of tb object
                if ( !tbInstance.namespace ){
                    tbInstance.namespace = typeof arguments[0] === &#x27;string&#x27;
                        ? arguments[0]
                        : arguments[0].namespace || tb.getId(); // if nothing helps, a unique id
                }

                // prepare .target property of tb object
                tbInstance.target = arguments[2] || false; // preset
                if ( !!arguments[2] ){
                    if ( arguments[2].jquery &amp;&amp; arguments[2][0] ){ // it is a jQuery result set
                        tbInstance.target = arguments[2][0];
                    } else {
                        tbInstance.target = arguments[2];
                    }
                } else {
                    tbInstance.target = null;
                }

                // if it is a DOM element:
                // - add class to DOM data
                // - $(target).addClass( &lt;namespacedClassname&gt; )
                // - if not already there add namespace to target data-tb attribute
                if ( tbInstance.target &amp;&amp; tbInstance.target.nodeType ){
                    var $that = $( tbInstance.target );

                    $that
                        .data( &#x27;tbo&#x27;, tbInstance );

                    // if element does not reside in the DOM &lt;head&gt; add class
                    if ( tbInstance.target !== document.head &amp;&amp; !$that.parents( &#x27;head&#x27; )[0] ){
                        $that
                            .addClass( tbInstance.namespace.replace( /\./g, &#x27;-&#x27;).toLowerCase() );
                    }

                    $that
                        .not(&#x27;[data-tb]&#x27;)
                        .attr( &#x27;data-tb&#x27;, tbInstance.namespace );
                }

                // create handlers array if necessary
                if ( !tbInstance.handlers ){
                    tbInstance.handlers = {};
                } else {
                    // if there are single named event handler functions,
                    // convert them to array of functions
                    $.each(
                        tbInstance.handlers,
                        function( key, value ){
                            if ( typeof value === &#x27;function&#x27; ){
                                tbInstance.handlers[key] = [ value ];
                            }
                        }
                    );
                }

                // add requirement loading
                if ( !!tbInstance[ &#x27;tb.require&#x27; ] &amp;&amp; tbInstance[ &#x27;tb.require&#x27;].length ){
                    // add requirement handling
                    //console.log( &#x27;requires&#x27;, tbInstance[ &#x27;tb.require&#x27; ] );
                    tb.head.load(
                        tbInstance[ &#x27;tb.require&#x27; ],
                        function(){
                            tbInstance[&#x27;tb.require&#x27;] = null;
                            delete tbInstance[&#x27;tb.require&#x27;];
                            tbInstance.trigger( &#x27;init&#x27; );
                        }
                    );
                } else {
                    tbInstance.trigger( &#x27;init&#x27; );
                }


                // add prop declared tb objects
                $.each(
                    tbInstance,
                    function( key, value ){
                        if ( typeof key === &#x27;string&#x27;
                            &amp;&amp; key.indexOf( &#x27;.&#x27; ) &gt; -1
                            &amp;&amp; key !== &#x27;tb.require&#x27;
                            ){ // prop name contains &quot;.&quot;, treat as tb class
                            tbInstance[key] = new tb( key, value, tbInstance );
                        }
                    }
                );

                return tbInstance;

            }

        } else {                         // arguments[0] is string or regex, return selector result

            return new TbSelector( arguments[0] );

        }

    };

    return tb;

})();



/**
 * stops event handling
 *
 * @function stop
 * @namespace tb
 * @static
 *
 * @param {boolean} pStopit - indicating whether to stop event handling
 *
 * @return {boolean} - true if event handling stopped, else false
 */
tb.stop = (function(pStopIt){
    var stopIt = pStopIt;
    return function( pStopIt ){
        return (stopIt = ( !!pStopIt ? pStopIt : stopIt ) );
    };
})( false );





/**
 * returns a unique id
 *
 * @function getId
 * @namespace tb
 * @static
 *
 * @return {string} - unique id
 */
tb.getId = function(){
    return &#x27;id-&#x27; + (new Date()).getTime() + &#x27;-&#x27; + Math.random().toString().replace(/\./, &#x27;&#x27;);
};




/**
 * tb.namespace() function
 *
 * sample calls:
 * tb.namespace( &#x27;in2.app.Dashboard&#x27; ) gets the constructor for dashboard
 *
 * and in the dashboard constructor:
 *
 * tb.namespace( &#x27;in2.app&#x27;, true ).Dashboard = function(){ ...
 *
 *
 * @function namespace
 * @namespace tb
 * @static
 *
 * @param {string} pNamespace
 * @param {boolean} [pForceCreation] - true =&gt; force creation of namespace object if it didnt exist before
 *
 * @return {Object}        namespaceObject
 */
tb.namespace = function( pNamespace, pForceCreation ){

    if ( typeof pNamespace !== &#x27;string&#x27; ){
        return false;
    }

    var namespaceArray = pNamespace.split(&#x27;.&#x27;);

    var walk = function( o, namespaceArray ) {

        if ( !o[ namespaceArray[0] ] &amp;&amp; !!pForceCreation ) {
            o[ namespaceArray[0] ] = {};
        }

        if ( namespaceArray.length &lt; 2 ){

            return o[ namespaceArray[0] ] || false;

        } else {

            if ( !!o[ namespaceArray[0] ] ) {
                o = o[ namespaceArray[0] ];
                namespaceArray.shift();
                return walk( o, namespaceArray );
            } else {
                return false;
            }

        }
    };

    return walk( window, namespaceArray );

};


/**
 * tb.bind() function
 *
 * sample calls:
 *
 * tb.bind( document.body )
 *
 * - scans the given element and all of its descendants
 *   in the DOM and looks for attributes &quot;data-tb&quot; in the nodes.
 * - resulting list will be scanned for those nodes that do not already
 *   have an tb object inside.
 * - creates a new tb object based on the class namespace given
 *   in the &quot;data-tb&quot; attribute
 * - stores it in the DOM element
 *
 * tb.bind( document.body, &#x27;n1.n2.&lt;className&gt;&#x27; [ , &lt;config data&gt; ] )
 *
 * - creates a new tb object based on the 2nd parameter, giving 3rd as constructor parameter
 * - stores it in the DOM element
 * THIS VARIANT WILL overwrite ANY tbo OBJECT THAT ALREADY RESIDES IN THE DOM NODE!
 * @function bind
 * @namespace tb
 * @static
 *
 * @param   {object}     pSelector      DOM node
 * @param   {string}     [pNamespace]   contains the namespace path to the class
 * @param   {variant}    [pConfig]      any data, will be used as a parameter when pNameSpace class is constructed @todo: &#x27;variant&#x27; is no valid data type. use &#x27;{Object|Array|String} or similar
 *
 * @return {void}
 */
tb.bind = function( pSelector, pNamespace, pConfig ){

    var selection;

    if ( pNamespace ){ // namespace is given
        selection = $( pSelector );
        selection.attr( &#x27;data-tb&#x27;, pNamespace );
    } else { // namespace not given, scan dom for data-tb attribute
        selection = $( pSelector )
            .find(&#x27;[data-tb]&#x27;)
            .andSelf()
            .filter(&#x27;[data-tb]&#x27;)
            .filter( function () {
                var obj = $(this).data( &#x27;tbo&#x27; ),
                    noTbObject = ( typeof obj !== &#x27;object&#x27; || ! obj instanceof tb );
                return noTbObject;
            });
    }

    // iterate over elements
    $.each(
        selection,
        function( key, value ){

            var namespace = pNamespace || $(this).attr(&#x27;data-tb&#x27;); // namespace of constructor

            new tb( namespace, pConfig, value );        // create tb object

        }
    );

};

/**
 * function tb.observable()
 *
 * - creates a function
 * - initializes a value to observe
 * - returns this function
 *
 * sample calls:
 *
 * o = tb.observable( {} );
 * o( { newData: &#x27;newData&#x27; } ); // change observable value
 * o.observe( function(){ ... }, true ); // will be triggered when observable value changes, true indicates only once
 *
 * @function observable
 * @namespace tb
 * @static
 *
 * @param {*} pStartValue - initial content of observable
 *
 * @return {function}  observableFunction
 */
tb.observable = function( pStartValue ){

    var observedValue = pStartValue;

    // make observable function to return in the end
    var observableFunction = function( pValue ){

        if ( pValue !== undefined &amp;&amp; observedValue !== pValue ){ // value has changed
            observedValue = pValue;
            observableFunction.notify();
        }
        return observedValue;
    };

    // list of all callbacks to trigger on observedValue change
    observableFunction.list = [];

    // function used to execute all callbacks
    observableFunction.notify = function(){

        // execute all callbacks
        $.each(
            observableFunction.list,
            function( key, func ){
                // currently only trigger functions allowed
                if ( $.isFunction( func ) ){
                    func( observedValue );
                    if ( func.once === true ){
                        observableFunction.list[key] = null;
                    }
                }
            }
        );

        // cleanup callback array
        observableFunction.list = $.map(
            observableFunction.list,
            function(value){
                return(value);
            }
        );

    };

    // function used to add a callbacks
    observableFunction.observe = function( pFunction, pOnce ){
        pFunction.once = pOnce || false;
        observableFunction.list.push( pFunction );
    };

    return observableFunction;
};

/**
 * tb.Model constructor
 * create and return a simple CRUD model
 *
 * @class Model
 * @constructor
 * @namespace tb
 *
 * @param {object} pConfig - config parameter, usually an object @todo: variant is no valid data type
 *
 * @return {object} - the model instance
 */
tb.Model = function ( pConfig ) {
    var that = this;

    // result element
    this.data = tb.observable( {} );
    this.config = {};

    // default
    $.extend(
        true,
        this.config,
        {   // default settings, reference only
            &#x27;create&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;PUT&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;read&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;GET&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;update&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;POST&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;delete&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;DELETE&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            }
        },
        pConfig
    );

};

tb.Model.prototype = (function(){

    // private

    // check parameters for any call
    function parmCheck( pCompare, pAgainst ){
        pAgainst = ( JSON.parse( JSON.stringify( pAgainst ) ) );

        $.each(
            pCompare,
            function( key, value ){
                if ( pAgainst &amp;&amp; typeof pAgainst[ key ] === typeof pCompare[ key ] ){
                    pAgainst[ key ] = pCompare[ key ];
                } else {
                    console.error( &#x27;parameter &#x27; + key + &#x27; missing or wrong type in &#x27;, pCompare );
                }
            }
        );

        return pAgainst;
    }

    return {

        &#x27;create&#x27;: function( pParams ){
            var o = $.extend( true, {}, this.config.create ),
                p = {}; // parameter object

            if ( !o.url ){
                console.error( &#x27;no create url given!&#x27;);
                return;
            }

            if ( o.params ){ // this indicates get or post parameters are expected
                p = parmCheck( pParams, o.params );
            }

            $.ajax(
                $.extend(
                    true,
                    o,
                    { // if params given, use microparse to fill them in url
                        url: p ? tb.parse( this.config.create.url, p ) : this.config.create.url
                    }
                )
            );

        },

        &#x27;read&#x27;: function( pParams ){

            var o = $.extend( true, {}, this.config.read ),
                p = {}; // parameter object

            if ( !o.url ){
                console.error( &#x27;no read url given!&#x27;);
                return;
            }

            if ( o.params ){ // this indicates get or post parameters are expected
                p = parmCheck( pParams, o.params );
            }

            $.ajax(
                $.extend(
                    true,
                    o,
                    { // if params given, use microparse to fill them in url
                        url: p ? tb.parse( this.config.read.url, p ) : this.config.read.url
                    }
                )
            );

        },

        &#x27;update&#x27;: function( pParams ){
            var o = $.extend( true, {}, this.config.update ),
                p = {}; // parameter object

            if ( !o.url ){
                console.error( &#x27;no update url given!&#x27;);
                return;
            }

            if ( o.params ){ // this indicates get or post parameters are expected
                p = parmCheck( pParams, o.params );
            }

            $.ajax(
                $.extend(
                    true,
                    o,
                    { // if params given, use microparse to fill them in url
                        url: p ? tb.parse( this.config.update.url, p ) : this.config.update.url
                    }
                )
            );

        },

        &#x27;delete&#x27;: function( pParams ){
            var o = $.extend( true, {}, this.config[&#x27;delete&#x27;] ),
                p = {}; // parameter object

            if ( !o.url ){
                console.error( &#x27;no delete url given!&#x27;);
                return;
            }

            if ( o.params ){ // this indicates get or post parameters are expected
                p = parmCheck( pParams, o.params );
            }

            $.ajax(
                $.extend(
                    true,
                    o,
                    { // if params given, use microparse to fill them in url
                        url: p ? tb.parse( this.config[&#x27;delete&#x27;].url, p ) : this.config.create.url
                    }
                )
            );

        }

    };

})();






/**
 * tb.parse() function
 * for each key/value in pObject, check string for {key}
 * replace occurence with &lt;value&gt;
 *
 * @function parse
 * @namespace tb
 * @static
 *
 * @param {string} pText - the text to parse
 * @param {object} pParse - hash object containing replacement key/&lt;value&gt;
 *
 * @return {string} - result string
 */
tb.parse = function( pText, pParse ){
    $.each( pParse, function(i, v){
        pText = pText.replace( (new RegExp(&#x27;\{&#x27;+i+&#x27;\}&#x27;, &#x27;g&#x27;)), v );
    });
    return pText;
};









/**
 * requirement handling
 */
(function(){
    // private

    function getTypeFromSrc( pSrc ){
        return pSrc.split(&#x27;?&#x27;)[0].split(&#x27;.&#x27;).pop();
    }

    // requirement constructor
    var _Requirement = function( pConfig ){

        var that = this,
            type = getTypeFromSrc( pConfig.src ), // filename extension
            typeConfigs = { // standard configuration types
                &#x27;css&#x27;: {
                    tag: &#x27;link&#x27;,
                    attributes: {
                        type: &#x27;text/css&#x27;,
                        rel: &#x27;stylesheet&#x27;,
                        href: &#x27;{src}&#x27;
                    }
                },
                &#x27;js&#x27;: {
                    tag: &#x27;script&#x27;,
                    attributes: {
                        type: &#x27;text/javascript&#x27;,
                        src: &#x27;{src}&#x27;
                    }
                }
            },
            typeConfig, // a single type configuration
            element,
            isTyped = !!typeConfigs[type];

        pConfig.type = type; // add type

        that.config = pConfig;

        //that.target = pConfig.target;
        that.src = pConfig.src;
        that.type = that.config.type = type;
        that.done = false;
        that.cb = that.config.cb || function(){};
        that.data = tb.observable( {} );

        // element &#x27;load&#x27; callback
        function onLoad( e ){

            if ( e &amp;&amp; e.data ){
                that.data( e.data );
            }
            that.done = true;
            if ( element.type === &#x27;js&#x27; ) {
                $( that.element ).remove();
            }
        }

        // execute onLoad only once
        onLoad.once = true;

        // handlers
        that.handlers = {
            &#x27;onLoad&#x27;: onLoad
        };


        if ( isTyped ) { // either *.css or *.js file

            // get default config for type
            typeConfig = typeConfigs[type];

            // create DOM element
            element = document.createElement( typeConfig.tag );
            element.async = true;
            element.onreadystatechange = element.onload = function() {
                var state = element.readyState;
                if (!that.done &amp;&amp; (!state || /loaded|complete/.test(state))) {
                    //console.log( &#x27;loaded&#x27;, element );
                    that.trigger( &#x27;onLoad&#x27; );
                }
            };

            // add attributes to DOM element
            $.each(
                typeConfig.attributes,
                function( key, value ){
                    $( element ).attr( key, tb.parse( value, that.config ) );
                }
            );

            // append node to head
            document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild( element );

            that.element = element;

        } else { // load via request if unknown type

            var f = function( data ){
                that.data( data );
                that.trigger( &#x27;onLoad&#x27;, data );
            };

            $.ajax(
                that.src,
                {
                    contentType: &#x27;text/plain&#x27;,
                    dataType: &#x27;text&#x27;,
                    success: f,
                    error: f
                }
            );
        }

    };

    _Requirement.prototype = {
        namespace: &#x27;_Requirement&#x27;
    };




    // requirement group constructor
    var _RequirementGroup = function( pConfig ){

        var that = this;

        that.type = pConfig.type;
        that.target = pConfig.target;

        that.requirements = {};

    };

    _RequirementGroup.prototype = {

        namespace: &#x27;_RequirementGroup&#x27;,

        load: function( pSrc, pCallback ){

            var that = this,
                rq = !!that.requirements[ pSrc ],
                functionWrapper;

            if ( !rq ){ // not loading or loaded: add a new requirement

                rq = that.requirements[ pSrc ] = new tb(
                    _Requirement,
                    {
                        src: pSrc,
                        cb: pCallback,
                        target: that.target
                    },
                    that.requirements
                );

            } else { // already loading or loaded

                rq = that.requirements[ pSrc ];

            }

            functionWrapper = function(){
                pCallback( this );
            };

            rq.on(
                &#x27;onLoad&#x27;,
                functionWrapper,
                true
            );

            if ( rq.done ){ // already loaded

                rq.trigger( &#x27;onLoad&#x27; );

            }

        }

    };




    var _Head = function( pConfig ){
        var that = this;

        that.config = pConfig;
        that.requirementGroups = {}; // will later contain requirementgroup tbo&#x27;s in &lt;head&gt;
    };

    _Head.prototype = {

        namespace: &#x27;_Head&#x27;,

        load: function( pSrc, pCallback ){

            var that = this,
                pCallback = pCallback || function( e ){ console.log( &#x27;onLoad dummy handler on&#x27;, e ); },
                type,
                rg,
                groupCallback;

            // load a group requirement ( multiple files )
            if ( typeof pSrc !== &#x27;string&#x27; ){

                groupCallback = (function( pSources, pCallback ){
                    return function( pElement ){
                        var index = pSources.indexOf( pElement.src );

                        pSources.splice( index, 1 );

                        if ( !pSources.length ){
                            pCallback();
                        }
                    };
                })( pSrc, pCallback );

                $.each(
                    pSrc,
                    function( key, value ){
                        that.load( value, groupCallback )
                    }
                );

                return;
            }

            // load a single requirement
            type = getTypeFromSrc( pSrc );
            rg = !!that.requirementGroups[type];

            if ( !rg ){ // add a new requirement group

                that.requirementGroups[ type ] = new tb(
                    _RequirementGroup,
                    {
                        type: type
                    },
                    that.requirementGroups
                )

            }

            rg = that.requirementGroups[ type ];

            rg.load( pSrc, pCallback );

        },

        data: function( pFileName, pData ){

            var that = this,
                type = getTypeFromSrc( pFileName),
                rg = that.requirementGroups[type] ? that.requirementGroups[type] : false,
                rq = rg ? ( rg.requirements[pFileName] ? rg.requirements[pFileName] : false ) : false;

            return rq ? rq.data( pData ) : &#x27;unknown: &#x27; + pFileName;
        }

    };

    // bind _Head instance
    tb.head = new tb(
        _Head,
        {   // configuration

        },
        document.head // ...to the document head
    );

})();

/**
 * document.ready bootstrap
 */
$(function(){   // jQuery document.ready

    // scan document for tb-data attributes
    tb.bind( document.body ); // find all tb dom nodes and add tb objects if not yet done

});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
